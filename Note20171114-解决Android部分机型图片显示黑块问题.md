这个问题主要是由于不同设备对纹理尺寸大小的限制不同而造成的。目前的主流设备一般都可以支持**4096*4096**，但是我们的项目中通过TP合图之后可能会存在部分超过这个限制的图片，作为开发者，我个人极不赞同使用超大图集直接加载，这样在加载单张图片的时候内存上升的非常快，而且会有瞬间卡顿的现象出现。解决方案很简单，把一张超大合图分解为多张小型合图，保证小图的尺寸在**4096*4096**以下即可；其次，是代码中要对这些合图的加载和释放过程进行合理的过渡和管理，我的解决方法是生成一份合图资源管理文件，这相当于建立了一张合图资源索引表，想要什么资源，直接去读表，再封装一层加载和卸载接口，这样就很方便了。
